<?php

declare(strict_types=1);

namespace Mridang\PHPUnitReporters;

use Exception;
use InvalidArgumentException;
use RuntimeException;
use SimpleXMLElement;

/**
 * Parses PHPUnit clover.xml coverage reports.
 *
 * This class reads a clover.xml file generated by PHPUnit and extracts
 * coverage metrics for each file, including statements, branches/methods,
 * lines, and uncovered line numbers.
 */
class CoverageReport
{
    /** @var array<string, FileCoverage> Parsed file coverage data. */
    private array $files = [];

    /**
     * Creates a new coverage report from a clover.xml file.
     *
     * @param string $cloverReportPath Absolute path to the clover.xml file.
     *
     * @throws InvalidArgumentException If the file does not exist.
     * @throws RuntimeException         If the XML cannot be parsed.
     */
    public function __construct(private readonly string $cloverReportPath)
    {
        if (! file_exists($cloverReportPath)) {
            throw new InvalidArgumentException(
                'Clover report file does not exist'
            );
        }

        $this->parse();
    }

    /**
     * Parses the clover.xml file and populates the files array.
     *
     * Handles both formats: files directly under <project> (test fixtures)
     * and files inside <package> elements (real PHPUnit output).
     *
     * @throws RuntimeException If the XML cannot be parsed.
     */
    private function parse(): void
    {
        $contents = file_get_contents($this->cloverReportPath);

        $previousUseErrors = libxml_use_internal_errors(true);
        try {
            $xml = @new SimpleXMLElement($contents);
        } catch (Exception $e) {
            $errors = libxml_get_errors();
            libxml_clear_errors();
            libxml_use_internal_errors($previousUseErrors);

            $errorMessage = $e->getMessage();
            if (!empty($errors)) {
                $errorMessage = trim($errors[0]->message);
            }

            throw new RuntimeException(
                'Failed to parse clover.xml: ' . $errorMessage,
                0,
                $e
            );
        }
        libxml_use_internal_errors($previousUseErrors);

        $files = [];

        // Handle files directly under a project (test fixtures format)
        foreach ($xml->project->file as $file) {
            $files[] = $file;
        }

        // Handle files inside packages (real PHPUnit clover format)
        foreach ($xml->project->package as $package) {
            foreach ($package->file as $file) {
                $files[] = $file;
            }
        }

        foreach ($files as $file) {
            $fileName = (string) $file['name'];
            $metrics = $file->metrics;

            $uncoveredLines = [];
            foreach ($file->line as $line) {
                if ((int) $line['count'] === 0) {
                    $uncoveredLines[] = (int) $line['num'];
                }
            }

            $this->files[$fileName] = new FileCoverage(
                statements: new CoverageMetrics(
                    total: (int) $metrics['statements'],
                    covered: (int) $metrics['coveredstatements'],
                ),
                branches: new CoverageMetrics(
                    // PHPUnit calls these 'methods' in clover.xml
                    total: (int) $metrics['methods'],
                    covered: (int) $metrics['coveredmethods'],
                ),
                lines: new CoverageMetrics(
                    total: (int) $metrics['elements'],
                    covered: (int) $metrics['coveredelements'],
                ),
                uncoveredLines: $uncoveredLines,
            );
        }
    }

    /**
     * Returns coverage data for all parsed files.
     *
     * @return array<string, FileCoverage> Map of absolute paths to coverage.
     */
    public function getFiles(): array
    {
        return $this->files;
    }

    /**
     * Calculates total coverage across all files.
     *
     * @return FileCoverage Aggregated coverage metrics.
     */
    public function getTotalCoverage(): FileCoverage
    {
        $statements = CoverageMetrics::zero();
        $branches = CoverageMetrics::zero();
        $lines = CoverageMetrics::zero();

        foreach ($this->files as $file) {
            $statements = $statements->add($file->statements);
            $branches = $branches->add($file->branches);
            $lines = $lines->add($file->lines);
        }

        return new FileCoverage($statements, $branches, $lines);
    }
}
